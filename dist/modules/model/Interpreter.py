from typing import Union, List, Tuple
from modules.utils import Utils
from modules.model import IRSIConfig, IEMAConfig, IInterpreterConfig




class Interpreter:
    """Interpreter Class

    This class takes care of processing a series of inputs and predictions. Based on the 
    provided configuration, it outputs a forecast value which will be used for trading.

    Class Properties:
        DEFAULT_RSI_OVERBOUGHT: float
            The default overbought value that will be used if the RSI is active and no overbought
            value has been provided
        DEFAULT_RSI_OVERSOLD: float
            The default oversold value that will be used if the RSI is active and no oversold
            value has been provided
        DEFAULT_EMA_DISTANCE: float
            The default distance value that will be used if the EMA is active and no distance
            value has been provided

    Instance Properties:
        long (float): 
            The percentage change that will be used in order to predict a long position. Changes under this
            value will be considered neutral.
        short (float): 
            The percentage change that will be used in order to predict a short position. Even though the 
            required positive is a positive number, it will be converted to negative in order to interpret
            the position. Changes above this value will be considered neutral.
        rsi (IRSIConfig): 
            (Optional) A dictionary containing the configuration that will be used to configure the RSI indicator.
        ema (IEMAConfig): 
            (Optional) A dictionary containing the configuration that will be used to configure the EMA indicator.
    """
    # Default RSI Properties
    DEFAULT_RSI_OVERBOUGHT: float = 80.0
    DEFAULT_RSI_OVERSOLD: float = 20.0

    # Default EMA Properties
    DEFAULT_EMA_DISTANCE: float = 0.5


    def __init__(self, config: IInterpreterConfig):
        """Initializes the Interpreter Class based on the provided configuration.

        Args:
            config: IInterpreterConfig
                The configuration to interpret predictions.
        """
        # Initialize the instance properties
        self.long = config['long']
        self.short = config['short']
        self.rsi = self._get_rsi_config(config.get('rsi'))
        self.ema = self._get_ema_config(config.get('ema'))








    ## Config Initializers ##



        

    def _get_rsi_config(self, config: IRSIConfig) -> IRSIConfig:
        """Retrieves the config dictionary for the RSI. Also fills the values that were not 
        provided with defaults.

        Defaults:
            overbought: 80.0
            oversold: 20.0

        Args:
            config: IRSIConfig 
                The config dict provided to initialize the class

        Returns:
            IRSIConfig
        """
        # Check if the RSI config was provided
        if isinstance(config, dict) and config['active']:
            # Return the final RSI config dict with defaults if applies
            return {
                "active": True,
                "overbought": config['overbought'] if isinstance(config.get('overbought'), (int, float)) else Interpreter.DEFAULT_RSI_OVERBOUGHT,
                "oversold": config['oversold'] if isinstance(config.get('oversold'), (int, float)) else Interpreter.DEFAULT_RSI_OVERSOLD,
            }

        # Otherwise, return the RSI as inactive
        else:
            return {"active": False}





    def _get_ema_config(self, config: IEMAConfig) -> IEMAConfig:
        """Retrieves the config dictionary for the EMA. Also fills the values that were not 
        provided with defaults.

        Defaults:
            distance: 0.5

        Args:
            config: IEMAConfig
                The config dict provided to initialize the class

        Returns:
            IEMAConfig
        """
        # Check if the EMA config was provided
        if isinstance(config, dict) and config['active']:
            # Return the final EMA config dict with defaults if applies
            return {
                "active": True,
                "distance": config['distance'] if isinstance(config.get('distance'), (int, float)) else Interpreter.DEFAULT_EMA_DISTANCE
            }

        # Otherwise, return the EMA as inactive
        else:
            return {"active": False}










    ## Prediction Interpretation ##







    def get_interpretation(
        self, 
        predictions: List[float],
        rsi: Union[float, None],
        short_ema: Union[float, None],
        long_ema: Union[float, None],
    ) -> Tuple[int, str]:
        """Builds and packs the interpretation based on provided predictions. The result
        will always be 0 (Neutral), 1 (Long) or -1 (Short).

        Args:
            predictions: List[float]
                List of predictions generated by Arima
            rsi: Union[float, None]
                Current RSI Value
            short_ema: Union[float, None]
                Current Short EMA Value
            long_ema: Union[float, None]
                Current Long EMA Value

        Returns:
            Tuple[int, str] (result, description)

        Possible Descriptions:
            long, short, long-neutralized-by-rsi-overbought, short-neutralized-by-rsi-oversold
            long-neutralized-by-ema-downtrend, short-neutralized-by-ema-uptrend

        Raises:
            ValueError: 
                If the length of the predictions list is less than 5
                If the RSI Value is not a valid float. (If RSI is active)
                If the Short or Long EMA values are not valid floats. (If EMA is active)
        """
        # Initialize the interpretation with the predictions' price change
        result, description = self._get_price_change_interpretation(predictions)

        # Check if the RSI state needs to be analyzed
        if result != 0 and self.rsi['active']:
            # Retrieve the RSI State
            overbought, oversold = self._get_rsi_state(rsi)

            # Neutralize a long in an overbought market
            if result == 1 and overbought:
                result = 0
                description = description + "-neutralized-by-rsi-overbought"

            # Neutralize a short in an oversold market
            if result == -1 and oversold:
                result = 0
                description = description + "-neutralized-by-rsi-oversold"

        # Check if the EMA state needs to be analyzed
        if result != 0 and self.ema['active']:
            # Retrieve the EMA State
            uptrend, downtrend = self._get_ema_state(short_ema, long_ema)

            # Neutralize a long in a downtrend
            if result == 1 and downtrend:
                result = 0
                description = description + "-neutralized-by-ema-downtrend"

            # Neutralize a short in an uptrend
            if result == -1 and uptrend:
                result = 0
                description = description + "-neutralized-by-ema-uptrend"


        # Return the packed interpretation
        return result, description








    def _get_price_change_interpretation(self, predictions: List[float]) -> Tuple[int, str]:
        """Given a list of predictions, it will calculate the change between the 
        first and the last. Based on this result and the config values provided will
        determine a result.
         1  =   Long
         0  =   Neutral
        -1  =   Short

        Args:
            predictions: List[float]
                The list of predictions generated by the Arima Model.

        Returns:
            Tuple[int, str] (1|0|-1, 'long'|'neutral'|'short')
        
        Raises:
            ValueError: 
                If the length of the predictions list is less than 5
        """
        # Make sure there are at least 5 items in the predictions list
        if len(predictions) < 5:
            raise ValueError(f"An interpretation requires a minimum of 5 predictions. Received {len(predictions)}")

        # Calculate the percentual change between the first and the last prediction
        change: float = Utils.get_percentage_change(predictions[0], predictions[-1])
        
        # Return the packed results accordingly
        if change >= self.long:
            return 1, 'long'
        elif change <= -(self.short):
            return -1, 'short'
        else:
            return 0, 'neutral'







    def _get_rsi_state(self, rsi: float) -> Tuple[bool, bool]:
        """Retrieves the current RSI state in a packed Tuple of booleans that stand for
        overbough, oversold.

        Args:
            rsi: float
                The current RSI value

        Returns:
            Tuple[bool, bool] (overbought, oversold)

        Raises:
            ValueError: If the RSI Value is not a valid float.
        """
        # Make sure the provided RSI value is valid
        if not isinstance(rsi, (int, float)):
            raise ValueError(f"The RSI value is not a valid float. Received: {str(rsi)}")

        # Return the packed RSI state
        return rsi >= self.rsi['overbought'], rsi <= self.rsi['oversold']








    def _get_ema_state(self, short_ema: float, long_ema: float) -> Tuple[bool, bool]:
        """Retrieves the current EMA state in a packed Tuple of booleans that stand for
        uptrend, downtrend.

        Args:
            short_ema: float
                The current Short EMA value
            long_ema: float
                The current Long EMA value

        Returns:
            Tuple[bool, bool] (uptrend, downtrend)

        Raises:
            ValueError: 
                If the Short or Long EMA values are not valid floats.
        """
        # Make sure the provided RSI value is valid
        if not isinstance(short_ema, (int, float)) or not isinstance(long_ema, (int, float)):
            raise ValueError(f"The EMA values provided are not valid floats. Received: {str(short_ema)}, {str(long_ema)}")

        # If short is above long means it could be an uptrend
        if short_ema > long_ema:
            # Calculate the distance from long to short
            distance: float = Utils.get_percentage_change(long_ema, short_ema)
            
            # If the distance meets the requirement, it is an uptrend
            return distance >= self.ema['distance'], False

        # If the long is above the short means it could be a downtrend
        elif short_ema < long_ema:
            # Calculate the distance from short to long
            distance: float = Utils.get_percentage_change(short_ema, long_ema)

            # If the distance meets the requirement, it is a downtrend
            return False, distance >= self.ema['distance']

        # Otherwise, the trend is unknown
        else:
            return False, False
        


        






    ## Interpreter Retriever ##





    def get_interpreter(self) -> IInterpreterConfig:
        """Returns the interpreter's data after having been initialized.

        Returns:
            IInterpreter
        """
        return {'long': self.long,'short': self.short,'rsi': self.rsi,'ema': self.ema}