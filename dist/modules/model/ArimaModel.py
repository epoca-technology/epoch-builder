from typing import List, Union
from numpy import around
from pandas import Series
from pmdarima import ARIMA
from modules.candlestick import Candlestick
from modules.database import save_prediction, get_prediction
from modules.model import ModelInterface, IModel, ArimaModelInterpreter, IArimaConfig, \
    IArimaModelConfig, IArimaModelInterpreterConfig, IPrediction, IPredictionMetaData



class ArimaModel(ModelInterface):
    """ArimaModel Class

    Initializes an ArimaModel instance that is ready to perform predictions.

    Class Properties:
        DEFAULT_LOOKBACK: int
            The default value that will be used if the lookback isn't provided.
        DEFAULT_PREDICTIONS: int
            The default value that will be used if the predictions isn't provided.
        DEFAULT_INTERPRETER: IArimaModelInterpreterConfig
            The default config that will be used if the interpreter isn't provided.

    Instance Properties:
        id: str
            The name of the model that makes it identifiable.
        arima: IArimaConfig
            The configuration that will be used to generate predictions.
        lookback: int
            The number of prediction candlesticks that will be used to generate predictions.
        predictions: int
            The number of predictions to be generated by Arima.
        interpreter: Interpreter
            The Interpreter instance that will be used to process Arima Predictions.
    """
    # Default Lookback
    DEFAULT_LOOKBACK: int = 300

    # Default # of Predictions
    DEFAULT_PREDICTIONS: int = 10

    # Default Interpreter
    DEFAULT_INTERPRETER: IArimaModelInterpreterConfig = { 'long': 0.05, 'short': 0.05 }





    ## Initialization ## 


    def __init__(self, config: IModel):
        """Initializes the instance properties as well as the Interpreter's Instance.

        Args:
            config: IModel
                The configuration to be used to initialize the model's instance
        """
        # Make sure there is 1 Arima Model
        if len(config['arima_models']) != 1:
            raise ValueError(f"A SingleModel can only be initialized if 1 configuration item is provided. \
                Received: {len(config['arima_models'])}")

        # Initialize the ID
        self.id: str = config['id']

        # Initialize the ArimaModel's Config
        model_config: IArimaModelConfig = config['arima_models'][0]

        # Initialize the Arima Configuration
        self.arima: IArimaConfig = self._get_arima_config(model_config['arima'])

        # Initialize the lookback
        self.lookback: int = model_config['lookback'] \
            if isinstance(model_config.get('lookback'), int) else ArimaModel.DEFAULT_LOOKBACK

        # Initialize the number of predictions
        self.predictions: int = model_config['predictions'] \
            if isinstance(model_config.get('predictions'), int) else ArimaModel.DEFAULT_PREDICTIONS

        # Initialize the Interpreter Instance
        self.interpreter: ArimaModelInterpreter = ArimaModelInterpreter(model_config['interpreter'] \
            if isinstance(model_config.get('interpreter'), dict) else ArimaModel.DEFAULT_INTERPRETER)

        # Validate the integrity of the model
        self._validate_integrity()





    def _get_arima_config(self, config: IArimaConfig) -> IArimaConfig:
        """Builds the Arima Config Dictionary. Optional values are filled with
        zeros if not provided.

        Args:
            config: IArimaConfig
                The configuration dict provided when initializing the instance.

        Returns:
            IArimaConfig
        """
        return {
            "p": config['p'],
            "d": config['d'],
            "q": config['q'],
            "P": config['P'] if isinstance(config.get('P'), int) else 0,
            "D": config['D'] if isinstance(config.get('D'), int) else 0,
            "Q": config['Q'] if isinstance(config.get('Q'), int) else 0,
            "m": config['m'] if isinstance(config.get('m'), int) else 0,
        }








    ## Predictions ##



    def predict(self, current_timestamp: int, enable_cache: bool = False) -> IPrediction:
        """In order to optimize performance, if cache is enabled, it will check the db
        before performing an actual prediction. If the prediction is not found, it will
        perform it and store it afterwards. If cache is not enabled, it will just 
        perform a traditional prediction without storing the results.

        Args:
            current_timestamp: int
                The current time in milliseconds.
            enable_cache: bool
                If true, it will check the db before calling the actual predict method.
        
        Returns:
            IPrediction
        """
        # Check if the cache is enabled
        if enable_cache:
            # Retrieve the candlestick range
            first_ot, last_ct = Candlestick.get_lookback_prediction_range(self.lookback, current_timestamp)

            # Retrieve it from the database
            pred: Union[IPrediction, None] = get_prediction(self.id, first_ot, last_ct)

            # Check if the prediction does not exist
            if pred == None:
                # Generate it
                pred = self._call_predict(current_timestamp, minimized_metadata=True)

                # Store it in the database
                save_prediction(self.id, first_ot, last_ct, pred)

                # Finally, return it
                return pred

            # Otherwise, return it
            else:
                return pred

        # Otherwise, handle a traditional prediction
        else:
            return self._call_predict(current_timestamp, minimized_metadata=False)






    def _call_predict(self, current_timestamp: int, minimized_metadata: bool) -> IPrediction:
        """Given the current time, it will perform a prediction and return it as 
        well as its metadata.

        Args:
            current_timestamp: int
                The current time in milliseconds.
            minimized_metadata: bool
                If this property is enabled, the metadata will only include the description.

        Returns:
            IPrediction
        """
        # Retrieve the close prices series
        close_prices: Series = Candlestick.get_lookback_close_prices(self.lookback, current_timestamp)

        # Initialize Arima safely
        try:
            # Initialize the Arima Model
            arima_model: ARIMA = ARIMA(
                order=(self.arima['p'], self.arima['d'], self.arima['q']), 
                seasonal_order=(self.arima['P'], self.arima['D'], self.arima['Q'], self.arima['m']),
                suppress_warnings=True
            )

            # Fit the model to the retrieved series
            arima_model.fit(close_prices)

            # Generate the predictions
            preds: List[float] = around(arima_model.predict(self.predictions), decimals=2).tolist()

            # Interpret the predictions
            result, description = self.interpreter.interpret(preds)

            # Build the metadata
            metadata: IPredictionMetaData = { 'd': description }
            if not minimized_metadata:
                metadata['pl'] = preds
            
            # Finally, return the prediction results
            return { "r": result, "t": int(current_timestamp), "md": [ metadata ] }
        except Exception as e:
            print(f"{self.id} Prediction Error: {str(e)}")
            return { "r": 0, "t": int(current_timestamp), "md": [{'d': 'neutral-due-to-error: ' + str(e)}] }







    ## General Retrievers ##






    def get_lookback(self) -> int:
        """Returns the lookback value of the model.

        Args:
            None

        Returns:
            int
        """
        return self.lookback








    def get_model(self) -> IModel:
        """Dumps the model's data into a dictionary that will be used
        to get the insights based on its performance.

        Args:
            None

        Returns:
            IModel
        """
        return {
            "id": self.id,
            "arima_models": [{
                "arima": self.arima,
                "lookback": self.lookback,
                "predictions": self.predictions,
                "interpreter": self.interpreter.get_interpreter(),
            }]
        }






    @staticmethod
    def is_config(model: IModel) -> bool:
        """Verifies if a model is an ArimaModel.

        Args:
            model: IModel
                A model configuration dict.

        Returns:
            bool
        """
        return ArimaModel._is_id(model['id']) and len(model['arima_models']) == 1 \
            and model.get('decision_models') == None









    ## Model Integrity Validation ##
    


    def _validate_integrity(self) -> None:
        """Verifies if the ID follows the ApdqPDQm guidelines. It will also make sure that its
        configuration matches the arima configuration from the ID.

        Raises:
            ValueError:
                If the ID of the model does not follow the Apdq or ApdqPDQm guideline.
                If there is a missmatch between the config in the ID and the actual
                    Arima configuration.
        """
        # Make sure the ID follows the proper guidelines
        if not ArimaModel._is_id(self.id):
            raise ValueError(f"The ID of the arima model must follow the Apdq or ApdqPDQm guideline. Received {self.id}")

        # Split the ID into chunks and save the Arima Configuration chunk
        chunk: str = self.id.split('A')[1]

        # Make sure the p, d and q values match perfectly
        if int(chunk[0]) != self.arima['p']:
            raise ValueError(f"Arima Configuration Missmatch for p. Received {chunk[0]} and {self.arima['p']}")
        if int(chunk[1]) != self.arima['d']:
            raise ValueError(f"Arima Configuration Missmatch for d. Received {chunk[1]} and {self.arima['d']}")
        if int(chunk[2]) != self.arima['q']:
            raise ValueError(f"Arima Configuration Missmatch for q. Received {chunk[2]} and {self.arima['q']}")

        # Check if it is a Sarima Model
        if len(chunk) == 7:
            # Make sure the P, D, Q and m values match perfectly
            if int(chunk[3]) != self.arima['P']:
                raise ValueError(f"Sarima Configuration Missmatch for P. Received {chunk[3]} and {self.arima['P']}")
            if int(chunk[4]) != self.arima['D']:
                raise ValueError(f"Sarima Configuration Missmatch for D. Received {chunk[4]} and {self.arima['D']}")
            if int(chunk[5]) != self.arima['Q']:
                raise ValueError(f"Sarima Configuration Missmatch for Q. Received {chunk[5]} and {self.arima['Q']}")
            if int(chunk[6]) != self.arima['m']:
                raise ValueError(f"Sarima Configuration Missmatch for m. Received {chunk[6]} and {self.arima['m']}")





    @staticmethod
    def _is_id(id: str) -> bool:
        """Checks if a string is a valid Arima Model ID.

        Args:
            id: str
                The ID of the model.

        Returns:
            bool
        """
        return isinstance(id, str) and id[0] == 'A' and (len(id) == 4 or len(id) == 8)