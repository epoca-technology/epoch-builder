from typing import List, Tuple, Dict
from itertools import product
from modules.types import IBacktestConfig, IModel, IArimaConfigValue, IBacktestID, IPositionExitCombinationPath,\
    IPositionExitCombinationRecord
from modules.utils.Utils import Utils
from modules.epoch.EpochFile import EpochFile
from modules.model.ArimaModel import ArimaModel
from modules.epoch.PositionExitCombination import PositionExitCombination





class BacktestConfigFactory:
    """BacktestConfigFactory Class

    This singleton manages the creation of Backtest Configuration files for a series of
    processes.

    Class Properties:
        ...
    """






    ## ArimaModel Backtest Configurations ##



    @staticmethod
    def build_arima_backtest_configs(epoch_id: str, idle_minutes_on_position_close: int) -> None:
        """Builds the Backtest Configuration files for all the ArimaModels in 
        all position exit combinations. It also generates a receipt in order to
        aid the process tracking.

        Args:
            epoch_id: str
                The ID of the Epoch.
            idle_minutes_on_position_close: int
                The number of minutes the models will remain idle on position close.
        Returns:
            None
        """
        # Init values
        model_count: Dict[IArimaConfigValue, int] = {}
        description: str = "Arima Models generated during the Epoch creation process. The purpose of this Backtest is to determine the best position exit combinations, as well asthe best performing models."

        # Iterate over each arima focus number
        for focus_number in range(1, 10, 1):
            # Build the models that will be backtested
            models: List[IModel] = BacktestConfigFactory._get_arima_models(focus_number)

            # Store the counts for the receipt
            model_count[focus_number] = len(models)

            # Iterate over each combination
            for rec in PositionExitCombination.get_records():
                # Build the backtest configuration
                config: IBacktestConfig = BacktestConfigFactory._build_config(
                    backtest_id=f"arima_{focus_number}",
                    description=description,
                    take_profit=rec["take_profit"],
                    stop_loss=rec["stop_loss"],
                    idle_minutes_on_position_close=idle_minutes_on_position_close,
                    models=models
                )

                # Build and save the backtest configuration
                BacktestConfigFactory._save_config(epoch_id, config)
            
        # Finally, save the receipt
        BacktestConfigFactory._save_arima_receipt(epoch_id, model_count)







    
    @staticmethod
    def _get_arima_models(focus_number: IArimaConfigValue) -> List[IModel]:
        """Builds all the possible ArimaModel combinations and returns them
        in IModel format.

        Args:
            focus_number: IArimaConfigValue

        Returns:
            List[IModel]
        """
        # Initialize the range that it will cover
        t: range = range(focus_number + 1)

        # Extract the raw combinations
        raw: List[Tuple[int, int, int]] = list(
            filter(
                lambda config: BacktestConfigFactory._is_arima_config(focus_number, config), 
                set(product(set(t), repeat = 3))
            )
        )

        # Return the processed combinations
        return [BacktestConfigFactory._build_arima_model(config) for config in raw]





    @staticmethod
    def _is_arima_config(focus_number: IArimaConfigValue, config: Tuple[int, int, int]) -> bool:
        """Verifies if a provided Arima config is valid and belongs to the provided
        focus number.

        Args:
            config: Tuple[int, int, int]
                A possible arima config generated by the product helper.
        
        Returns:
            bool
        """
        return focus_number in config and config[0] != 0 and config[2] != 0






    @staticmethod
    def _build_arima_model(config: Tuple[int, int, int]) -> IModel:
        """Builds an ArimaModel based on the provided combination.

        Args:
            config: Tuple[int, int, int]
                An ArimaModel configuration generated by the product helper.
        
        Returns:
            IModel
        """
        return {
            "id": f"A{config[0]}{config[1]}{config[2]}",
            "arima_models":[{
                "lookback": ArimaModel.DEFAULT_LOOKBACK,
                "predictions": ArimaModel.DEFAULT_PREDICTIONS,
                "arima": { "p": config[0], "d": config[1], "q": config[2] },
                "interpreter": ArimaModel.DEFAULT_INTERPRETER
            }]
        }





    @staticmethod
    def _save_arima_receipt(epoch_id: str, model_count: Dict[IArimaConfigValue, int]) -> IModel:
        """Builds an ArimaModel based on the provided combination.

        Args:
            config: Tuple[int, int, int]
                An ArimaModel configuration generated by the product helper.
        
        Returns:
            IModel
        """
        # Init values
        receipt: str = f"{epoch_id}: Arima Model Backtest Configs\n\n"
        pe_combs: List[IPositionExitCombinationRecord] = PositionExitCombination.get_records()

        # Configuration
        receipt += f"Creation: {Utils.from_milliseconds_to_date_string(Utils.get_time())}\n"
        receipt += f"Position Exit Combinations: {len(pe_combs)}\n\n"

        # Models by focus number
        receipt += f"ArimaModels:\n"
        for focus_number, count in model_count.items():
            receipt += f"{focus_number}: {count}\n"
        receipt += f"\nTotal: {sum(model_count.values())}\n\n"

        # Models by position exit combination
        receipt += f"Backtest Configurations:\n\n"
        for comb in pe_combs:
            receipt += f"\n{comb['path']}:\n"
            for focus_number in range(1, 10, 1):
                 receipt += f"    -arima_{focus_number}:\n"
        receipt += "\n"

        # Finally, save the receipt
        path: str = f"{epoch_id}/{EpochFile.BACKTEST_PATH['configurations']}/arima_models_receipt.txt"
        EpochFile.write(path, receipt)





    ## Shortlisted Keras Regressions ##





    ## Shortlisted Keras Classifications ##










    ## Misc Helpers ##





    @staticmethod
    def _save_config(epoch_id: str, config: IBacktestConfig) -> None:
        """Builds a Backtest Configuration File based on provided values.

        Args:
            epoch_id: str
                The ID of the Epoch
            config: IBacktestConfig
                The configuration of the Backtest that will be saved.
        """
        # Initialize the position exit's path
        pe_path: IPositionExitCombinationPath = PositionExitCombination.get_path(config["take_profit"], config["stop_loss"])
        
        # Build the file's path
        path: str = f"{epoch_id}/{EpochFile.BACKTEST_PATH['configurations']}/{pe_path}/{config['id']}.json"

        # Finally, save the file
        EpochFile.write(path, config, indent=4)







    @staticmethod
    def _build_config(
        backtest_id: IBacktestID,
        description: str,
        take_profit: float,
        stop_loss: float,
        idle_minutes_on_position_close: int,
        models: List[IModel]
    ) -> IBacktestConfig:
        """Builds a Backtest Configuration File based on provided values.

        Args:
            backtest_id: IBacktestID
                The ID of the Backtest.
            description: str
                A brief description of the Backtest.
            take_profit: float
            stop_loss: float
                Position exit combination
            idle_minutes_on_position_close: int
                The number of minutes the models will remain idle on position close.
            models: List[IModel]
                The list of models to be backtested.
        Returns:
            IBacktestConfig
        """
        return {
            "id": backtest_id,
            "description": description,
            "take_profit": take_profit,
            "stop_loss": stop_loss,
            "idle_minutes_on_position_close": idle_minutes_on_position_close,
            "models": models
        }